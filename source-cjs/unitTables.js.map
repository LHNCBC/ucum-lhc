{"version":3,"sources":["../source/unitTables.js"],"names":["Ucum","require","UnitTablesFactory","constructor","unitNames_","unitCodes_","codeOrder_","unitStrings_","unitDimensions_","unitSynonyms_","massDimIndex_","unitsCount","Object","keys","length","addUnit","theUnit","uName","addUnitName","addUnitCode","addUnitString","getProperty","addUnitDimension","err","push","Error","uCode","dimVec","dim_","dimVec_","d","uString","caseSensitive_","uEntry","mag","unit","uDim","buildUnitSynonyms","code","uSyns","synonyms_","synsAry","split","aLen","a","theSyn","trim","addSynonymCodes","name_","theCode","theSynonyms","words","wLen","w","word","synCodes","indexOf","getUnitByCode","retUnit","getUnitByName","undefined","sepPos","codeSep_","substr","retUnits","uLen","i","csCode_","getUnitByString","retAry","getUnitsByDimension","unitsArray","console","log","getUnitBySynonym","uSyn","retObj","foundCodes","fLen","f","message","getAllUnitNames","getUnitNamesList","nameList","codes","sort","compareCodes","getMassDimensionIndex","b","replace","toLowerCase","getAllUnitCodes","allUnitsByDef","unitsList","u","allUnitsByName","cols","sep","unitBuff","cLen","nameRecs","rec","c","Array","join","cbuf","printUnits","doLong","codeList","unitString","curUnit","curDim","csUnitString_","baseFactor_","cnv_","defError_","unitTablesInstance","UnitTables","getInstance"],"mappings":"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","sourcesContent":["/**\n * This class manages Hashtables that provide references to\n * defined units.\n *\n * @author Lee Mericle, based on java version by Gunther Schadow\n *\n */\n\nvar Ucum = require('./config.js').Ucum;\n\nclass UnitTablesFactory {\n\n  /**\n   * Constructor.  This creates the empty unit tables (hashes) once. After the\n   * tables are created, it redefines this constructor to throw an error\n   * stating that the constructor is no longer available and that the\n   * getInstance function must be used.   Here's a description of the first\n   * and then all subsequent calls to this constructor.\n   *\n   * First call to constructor:\n   * 1. creates  OBJECT1\n   * 2. initializes attributes of OBJECT1\n   * 3. stores reference to OBJECT1.prototype in holdthis local variable\n   * 4. redefines OBJECT1 as a function that throws an error\n   * 5. defines the getInstance function (which is also defined outside of\n   *    the class definition - see below).\n   *\n   * All subsequent calls to constructor:\n   * 1. throw error message referring to getInstance\n   * 2. call getInstance, returns this - which is OBJECT1.\n   */\n  constructor() {\n\n    /**\n     * Tracks units by name\n     * @type hash - key is the name;\n     *              value is an array of references to the Unit objects\n     *              with the name.  More than one unit may have the same\n     *              name, e.g., \"second\", which is shared by the base unit\n     *              with the code = \"s\" and the unit with code = \"'\".\n     */\n    this.unitNames_ = {};\n\n    /**\n     * Tracks units by code using case-sensitive version.\n     *\n     * @type hash - key is the code;\n     *              value is the reference to the Unit object.  Codes must\n     *              be unique.\n     */\n    this.unitCodes_ = {};\n\n    /**\n     * Keeps track of the order in which units are defined.  The order is\n     * important because unit definitions build on previous definitions.\n     *\n     * @type {Array}\n     */\n    this.codeOrder_ = [] ;\n\n    /**\n     * Tracks units by unit strings, e.g., cm-1\n     *\n     * @type hash - key is the unit string\n     *              value is an array of unit objects with that ciUnitString.\n     */\n    this.unitStrings_ = {};\n\n    /**\n     * Tracks units by Dimension vector\n     *\n     * @type hash - key is the dimension vector (not the object, just the\n     *              vector);\n     *              value is an array of references to the Unit objects\n     *              with that vector.  More than one unit may have the same\n     *              unit vector, and this can be used to provide a list\n     *              of commensurable units.\n     */\n    this.unitDimensions_ = {};\n\n    /**\n     * Maps synonyms to units.   Not built until first requested.\n     *\n     * @type hash - key is the synonym\n     *              value is an array of references to Unit objects that\n     *              include that synonym.\n     */\n     this.unitSynonyms_ = {};\n\n    /*\n     * Holds onto the index of the index of the dimension vector flag for\n     * the base mass unit (gram).  This is set when the base unit (gram) is\n     * created, and is stored here so that it doesn't have to be found\n     * over and over again to try to determine whether or not a unit is\n     * mass-based (for mole<->mass conversions)\n     *\n     * @type integer\n     */\n    this.massDimIndex_ = 0;\n  }\n\n\n  /**\n   * Provides the number of unit objects written to the tables, using the\n   * codes table since codes must be unique.\n   *\n   * @returns count of the number of unit objects in the unitCodes_ table.\n   */\n  unitsCount() {\n    return Object.keys(this.unitCodes_).length ;\n  }\n\n\n  /**\n   * Adds a Unit object to the tables.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws passes on an error if one is thrown by the called functions for\n   *  a problem with the unit code or unit name\n   */\n  addUnit(theUnit) {\n\n    let uName = theUnit['name_'] ;\n    if (uName) {\n      this.addUnitName(theUnit);\n    }\n\n    this.addUnitCode(theUnit);\n    this.addUnitString(theUnit);\n\n    try {\n      if (theUnit['dim_'].getProperty('dimVec_'))\n        this.addUnitDimension(theUnit);\n    }\n    catch(err){\n      // do nothing - throws error if the property is null\n      // and that's OK here.\n    }\n\n  } // end addUnit\n\n\n  /**\n   * Adds a Unit object to the unitNames_ table.  More than one unit\n   * can have the same name, e.g., the two units with the name \"second\",\n   * where the code for one of them is 's' and the code for the other is\n   * \"'\".  Because of this, an array of unit objects is stored for the\n   * name.  In most cases it will be an array of one object, but this\n   * clarifies that there may be more than one.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws an error if the unit has no name\n   */\n  addUnitName(theUnit) {\n\n    let uName = theUnit['name_'];\n\n    if (uName) {\n      if (this.unitNames_[uName])\n        this.unitNames_[uName].push(theUnit);\n      else\n        this.unitNames_[uName] = [theUnit];\n    }\n    else\n      throw(new Error('UnitTables.addUnitName called for a unit with no name.  ' +\n            `Unit code = ${theUnit['csCode_']}.`));\n\n  } // end addUnitName\n\n\n  /**\n   * Adds a Unit object to the unitCodes_, unitUcCodes_, unitLcCodes_ and\n   * codeOrder_ tables.  This also sets the mass dimension index when the\n   * base mass unit (gram) is read.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws an error if the unitCodes_ table already contains a unit with\n   *  the code\n   */\n  addUnitCode(theUnit) {\n\n    let uCode = theUnit['csCode_'];\n    if (uCode) {\n\n      if (this.unitCodes_[uCode])\n        throw(new Error(`UnitTables.addUnitCode called, already contains entry for ` +\n              `unit with code = ${uCode}`));\n      else {\n        this.unitCodes_[uCode] = theUnit;\n        this.codeOrder_.push(uCode);\n        if (uCode == 'g') {\n          let dimVec = theUnit.dim_.dimVec_;\n          let d = 0;\n          for (; d < dimVec.length && dimVec[d] < 1; d++) ;\n          this.massDimIndex_ = d;\n        }\n      }\n    }\n    else\n      throw(new Error('UnitTables.addUnitCode called for unit that has ' +\n                      'no code.')) ;\n\n  } // end addUnitCode\n\n\n  /**\n   * Adds a unit object to the unitStrings_ table.  More than one unit\n   * can have the same string, so an array of unit objects is stored\n   * for the string.  The unit string is the string that creates a non-base\n   * unit, e.g., a Newton has a unit code of N, a name of Newton, and a\n   * unitString of kg.m/s2.\n   *\n   * If the unit has no string, nothing is stored and no error is reported.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   */\n  addUnitString(theUnit) {\n\n    let uString = null;\n    if (Ucum.caseSensitive_ == true)\n      uString = theUnit['csUnitString_'];\n    else\n      uString = theUnit['ciUnitString_'];\n\n    if (uString) {\n      let uEntry = {mag: theUnit['baseFactorStr_'], unit: theUnit};\n      if (this.unitStrings_[uString])\n        this.unitStrings_[uString].push(uEntry);\n      else\n        this.unitStrings_[uString] = [uEntry];\n    }\n  } // end addUnitString\n\n\n  /**\n   * Adds a Unit object to the unitDimensions_ table.  More than one unit\n   * can have the same dimension (commensurable units have the same dimension).\n   * Because of this, an array of unit objects is stored for the\n   * dimension.\n   *\n   * @param theUnit the unit to be added\n   * @returns nothing\n   * @throws an error if the unit has no dimension\n   */\n  addUnitDimension(theUnit) {\n\n    let uDim = theUnit['dim_'].getProperty('dimVec_');\n\n    if (uDim) {\n      if (this.unitDimensions_[uDim])\n        this.unitDimensions_[uDim].push(theUnit);\n      else\n        this.unitDimensions_[uDim] = [theUnit];\n    }\n    else\n      throw(new Error('UnitTables.addUnitDimension called for a unit with no dimension.  ' +\n          `Unit code = ${theUnit['csCode_']}.`));\n\n  } // end addUnitDimension\n\n\n  /**\n   * Builds the unitSynonyms_ table. This is called the first time the\n   * getUnitsBySynonym method is called.  The table/hash contains each word\n   * (once) from each synonym as well as each word from each unit name.\n   *\n   * Hash keys are the words.  Hash values are an array of unit codes for\n   * each unit that has that word in its synonyms or name.\n   *\n   * @returns nothing\n   */\n  buildUnitSynonyms() {\n\n    for (let code in this.unitCodes_) {\n      let theUnit = this.unitCodes_[code];\n      let uSyns = theUnit.synonyms_ ;\n\n      // If the current unit has synonyms, process each synonym (often multiples)\n      if (uSyns) {\n        let synsAry = uSyns.split(';');\n        if (synsAry[0] !== '') {\n          let aLen = synsAry.length;\n          for (let a = 0; a < aLen; a++) {\n            let theSyn = synsAry[a].trim();\n\n            // call addSynonymCodes to process each word in the\n            // synonym, e.g., \"British fluid ounces\"\n            this.addSynonymCodes(code, theSyn) ;\n          } // end do for each synonym\n        } // end if the current unit has a non-null synonym attribute\n      } // end if the unit has any synonyms\n\n      // Now call addSynonymCodes to process each word in the unit's name\n      this.addSynonymCodes(code, theUnit.name_) ;\n    } // end do for each unit\n   } // end buildUnitSynonyms\n\n\n  /**\n   * Adds unit code entries to the synonyms table for a string containing\n   * one or more words to be considered as synonyms.\n   *\n   * @param theCode the unit code to be connected to the synonyms\n   * @param theSynonyms a string containing one or more words to be\n   *  considered synonyms (and thus to be added to the unitSynonyms hash).\n   */\n  addSynonymCodes(theCode, theSynonyms) {\n\n    let words = theSynonyms.split(' ');\n    let wLen = words.length;\n\n    for (let w = 0; w < wLen; w++) {\n      let word = words[w];\n\n      // if there is already a synonyms entry for the word,\n      // get the array of unit codes currently assigned to\n      // the word and add the code for the current word to\n      // the synonyms array if it's not already there.\n      if (this.unitSynonyms_[word]) {\n        let synCodes = this.unitSynonyms_[word];\n        if (synCodes.indexOf(theCode) === -1) {\n          this.unitSynonyms_[word].push(theCode);\n        }\n      }\n      // else there are no synonyms entry for the word.  Create a\n      // synonyms array for the word, setting it to contain the unit code.\n      else {\n        this.unitSynonyms_[word] = [theCode];\n      }\n    } // end do for each word in the synonyms being processed\n\n  } // end addSynonymCodes\n\n\n  /**\n   *  Returns a unit object with a case-sensitive code matching the\n   *  uCode parameter, or null if no unit is found with that code.\n   *\n   *  @param uCode the code of the unit to be returned\n   *  @returns the unit object or null if it is not found\n   */\n  getUnitByCode(uCode) {\n    let retUnit = null ;\n    if (uCode) {\n      retUnit = this.unitCodes_[uCode];\n    }\n    return retUnit ;\n  }\n\n\n  /**\n   *  Returns a array of unit objects based on the unit's name.  Usually this\n   *  will be an array of one, but there may be more, since unit names are\n   *  not necessarily unique.\n   *\n   *  @param uName the name of the unit to be returned.  If more than one\n   *  unit has the same name and you only want one specific unit, append the\n   *  csCode of the unit you want to the end of the name, separated by the\n   *  Ucum.codeSep_ value, e.g., inch - [in_i] vs. inch - [in_us].\n   *  @returns null if no unit was found for the specified name OR an array of\n   *  unit objects with the specified name.  Normally this will be an array\n   *  of one object.\n   *  @throws an error if no name is provided to search on\n   */\n  getUnitByName(uName) {\n\n    if (uName === null || uName === undefined) {\n      throw (new Error('Unable to find unit by name because no name was provided.'));\n    }\n    let sepPos = uName.indexOf(Ucum.codeSep_);\n    let uCode = null;\n    if (sepPos >= 1) {\n      uCode = uName.substr(sepPos + Ucum.codeSep_.length);\n      uName = uName.substr(0, sepPos);\n    }\n    let retUnits = this.unitNames_[uName] ;\n    if (retUnits) {\n      let uLen = retUnits.length ;\n\n      if (uCode && uLen > 1) {\n        let i = 0;\n        for (; retUnits[i].csCode_ !== uCode && i < uLen; i++);\n        if (i < uLen)\n          retUnits = [retUnits[i]];\n        else {\n          retUnits = null;\n        }\n      } // end if we need to find both a name and a code\n    } // end if we got an array of units\n    return retUnits ;\n\n  } // end getUnitByName\n\n\n  /**\n   *  Returns an array of unit objects with the specified unit string.\n   *  The array may contain one or more unit reference objects.\n   *  Or none, if no units have a matching unit string (which is not\n   *  considered an error)\n   *\n   *  @param name the name of the unit to be returned\n   *  @returns the array of unit references or null if none were found\n   */\n  getUnitByString(uString) {\n    let retAry = null ;\n    if (uString) {\n      retAry = this.unitStrings_[uString] ;\n      if (retAry === undefined)\n        retAry = null;\n    }\n    return retAry ;\n  }\n\n\n  /**\n   *  Returns a array of unit objects based on the unit's dimension vector.\n   *\n   *  @param uName the dimension vector of the units to be returned.\n   *\n   *  @returns null if no unit was found for the specified vector OR an array of\n   *  one or more unit objects with the specified vector.\n   *  @throws an error if no vector is provided to search on\n   *  logs an error to the console if no unit is found\n   */\n  getUnitsByDimension(uDim) {\n\n    let unitsArray = null ;\n    if (uDim === null || uDim === undefined) {\n      throw (new Error('Unable to find unit by because no dimension ' +\n                       'vector was provided.'));\n    }\n\n    unitsArray = this.unitDimensions_[uDim] ;\n    if (unitsArray === undefined || unitsArray === null) {\n      console.log(`Unable to find unit with dimension = ${uDim}`);\n    }\n\n    return unitsArray ;\n\n  } // end getUnitsByDimension\n\n\n  /**\n   *  Returns a array of unit objects that include the specified synonym.\n   *\n   *  @param uSyn the synonym of the units to be returned.\n   *\n   *  @returns an object with two of the following three elements:\n   *   'status' will be error, failed or succeeded\n   *   'msg' will be included for returns with status = error or failed and\n   *     will explain why the request did not return any units\n   *   'units' any array of unit objects with the specified synonym will be\n   *     returned for requests with status = succeeded\n   */\n  getUnitBySynonym(uSyn) {\n\n    let retObj = {} ;\n    let unitsArray = [];\n\n    try {\n      if (uSyn === null || uSyn === undefined) {\n        retObj['status'] = 'error' ;\n        throw (new Error('Unable to find unit by synonym because no synonym ' +\n            'was provided.'));\n      }\n      // If this is the first request for a unit by synonym, build the hash map\n      if (Object.keys(this.unitSynonyms_).length === 0) {\n        this.buildUnitSynonyms();\n      }\n      let foundCodes = [];\n      foundCodes = this.unitSynonyms_[uSyn];\n      if (foundCodes) {\n        retObj['status'] = 'succeeded';\n        let fLen = foundCodes.length;\n        for (let f = 0; f < fLen; f++) {\n          unitsArray.push(this.unitCodes_[foundCodes[f]]);\n        }\n        retObj['units'] = unitsArray ;\n      }\n      if (unitsArray.length === 0) {\n        retObj['status'] = 'failed' ;\n        retObj['msg'] = `Unable to find any units with synonym = ${uSyn}`;\n      }\n    }\n    catch(err) {\n      retObj['msg'] = err.message ;\n    }\n    return retObj ;\n  } // end getUnitBySynonym\n\n\n  /**\n   * Gets a list of all unit names in the Unit tables\n   *\n   * @returns an array of the unit names\n   */\n  getAllUnitNames() {\n    return Object.keys(this.unitNames_);\n  } // end getAllUnitNames\n\n\n  /**\n   * Gets a list of all unit names in the tables.  Where more than one\n   * unit has the same name, the unit code, in parentheses, is appended\n   * to the end of the name.\n   *\n   * @returns {Array}\n   */\n  getUnitNamesList() {\n    let nameList = [];\n    let codes = Object.keys(this.unitCodes_);\n    codes.sort(this.compareCodes) ;\n    let uLen = codes.length;\n    for (let i = 0; i < uLen; i++) {\n      nameList[i] = codes[i] + Ucum.codeSep_ + this.unitCodes_[codes[i]].name_\n    } // end do for each code\n    return nameList ;\n  }\n\n\n  /*\n   * Returns the mass dimension index\n   * @returns this.massDimIndex_\n   */\n  getMassDimensionIndex() {\n    return this.massDimIndex_ ;\n  }\n\n  /**\n   * This provides a sort function for unit codes so that sorting ignores\n   * square brackets and case.\n   *\n   * @param a first value\n   * @param b second value\n   * @returns -1 if a is should fall before b; otherwise 1.\n   */\n  compareCodes(a, b) {\n    a = a.replace(/[\\[\\]]/g, '');\n    a = a.toLowerCase();\n    b = b.replace(/[\\[\\]]/g, '');\n    b = b.toLowerCase();\n    return (a < b) ? -1 : 1 ;\n  }\n\n\n  /**\n   * Gets a list of all unit codes in the Unit tables\n   *\n   * @returns an array of the unit names\n   */\n  getAllUnitCodes() {\n    return Object.keys(this.unitCodes_);\n  } // end getAllUnitNames\n\n\n  /**\n   * This is used to get all unit objects.  Currently it is used\n   * to get the objects to write to the json ucum definitions file\n   * that is used to provide prefix and unit definition objects for\n   * conversions and validations.\n   *\n   * @returns an array containing all unit objects, ordered by definition\n   * order\n   */\n  allUnitsByDef() {\n\n    let unitsList = [];\n    let uLen = this.codeOrder_.length ;\n    for (let u = 0; u < uLen; u++) {\n      unitsList.push(this.getUnitByCode(this.codeOrder_[u]));\n    }\n    return unitsList ;\n  } // end allUnitsByDef\n\n\n  /**\n   * This is used to get all unit objects, ordered by unit name.  Currently it\n   * is used to create a csv list of all units.\n   * @param sep separator character (or string) to be used to separate each\n   *  column in the output.  Optional, defaults to '|' if not specified.\n   *  (Used to use ; but the synonyms use that extensively).  Don't use a\n   *  comma or any other punctuation found in the output data.\n   * @returns a buffer containing all unit objects, ordered by name\n   * order\n   */\n  allUnitsByName(cols, sep) {\n    if (sep === undefined || sep === null)\n      sep = '|';\n    let unitBuff = '';\n    let unitsList = this.getAllUnitNames();\n    let uLen = unitsList.length;\n    let cLen = cols.length;\n    for (let i = 0; i < uLen; i++) {\n      let nameRecs = this.getUnitByName(unitsList[i]);\n      for (let u = 0; u < nameRecs.length; u++) {\n        let rec = nameRecs[u];\n        for (let c = 0; c < cLen; c++) {\n          if (c > 0)\n            unitBuff += sep;\n          if (cols[c] === 'dim_') {\n            if (rec.dim_ !== null && rec.dim_ !== undefined &&\n                rec.dim_.dimVec_ instanceof Array)\n              unitBuff += '[' + rec.dim_.dimVec_.join(',') + ']';\n            else\n              unitBuff += '';\n          }\n          else {\n            let cbuf = rec[cols[c]];\n            if (typeof cbuf === 'string')\n              unitBuff += cbuf.replace(/[\\n\\r]/g, ' ');\n            else\n              unitBuff += cbuf ;\n          }\n        } // end do for each column requested\n        unitBuff += '\\r\\n';\n      } // end do for each unit in the unit names array\n    }\n    return unitBuff ;\n  } // end allUnitsByName\n\n\n  /**\n   * This creates a list of all units in the tables.  It uses the byCode\n   * table, and uses the codeOrder_ array to determine the order in which\n   * the units are listed.\n   *\n   * @param doLong boolean indicating how much to output.  If true, all data\n   *  from the unit objects is included.   If false, only a few major values\n   *  are included.\n   * @param sep separator character (or string) to be used to separate each\n   *  column in the output.  Optional, defaults to '|' if not specified.\n   *  (Used to use ; but the synonyms use that extensively).\n   * @returns {string} buffer containing all the listings\n   */\n  printUnits(doLong, sep) {\n    if (doLong === undefined)\n      doLong = false ;\n    if (sep === undefined)\n      sep = '|';\n    let codeList = '';\n    let uLen = this.codeOrder_.length ;\n    let unitString = 'csCode' + sep  ;\n    if (doLong) {\n      unitString += 'ciCode' + sep ;\n    }\n    unitString += 'name' + sep ;\n    if (doLong)\n      unitString += 'isBase' + sep ;\n    unitString += 'magnitude' + sep + 'dimension' + sep + 'from unit(s)' + sep +\n                  'value' + sep + 'function' + sep ;\n    if (doLong)\n      unitString += 'property' + sep + 'printSymbol' + sep + 'synonyms' + sep +\n                    'source' + sep + 'class' + sep + 'isMetric' + sep +\n                    'variable' + sep + 'isSpecial' + sep + 'isAbitrary' + sep ;\n    unitString += 'comment';\n    codeList = unitString + '\\n' ;\n\n    for (let u = 0; u < uLen; u++) {\n      let curUnit = this.getUnitByCode(this.codeOrder_[u]);\n      unitString = this.codeOrder_[u] + sep ;\n      if (doLong) {\n        unitString += curUnit.getProperty('ciCode_') + sep ;\n      }\n      unitString += curUnit.getProperty('name_') + sep ;\n      if (doLong) {\n        if (curUnit.getProperty('isBase_'))\n          unitString += 'true' + sep ;\n        else\n          unitString += 'false' + sep ;\n      }\n      unitString += curUnit.getProperty('magnitude_')  + sep;\n      let curDim = curUnit.getProperty('dim_');\n      if (curDim) {\n        unitString += curDim.dimVec_ + sep ;\n      }\n      else {\n        unitString += 'null' + sep;\n      }\n      if (curUnit.csUnitString_)\n        unitString += curUnit.csUnitString_ + sep + curUnit.baseFactor_ + sep ;\n      else\n        unitString += 'null' + sep + 'null' + sep;\n\n      if (curUnit.cnv_)\n        unitString += curUnit.cnv_ + sep ;\n      else\n        unitString += 'null' + sep ;\n\n      if (doLong) {\n        unitString += curUnit.getProperty('property_') + sep +\n                      curUnit.getProperty('printSymbol_') + sep +\n                      curUnit.getProperty('synonyms_') + sep +\n                      curUnit.getProperty('source_') + sep +\n                      curUnit.getProperty('class_') + sep +\n                      curUnit.getProperty('isMetric_') + sep +\n                      curUnit.getProperty('variable_') + sep +\n                      curUnit.getProperty('isSpecial_') + sep +\n                      curUnit.getProperty('isArbitrary_') + sep ;\n      }\n      if (curUnit.defError_)\n        unitString += 'problem parsing this one, deferred to later.' ;\n      codeList += unitString + '\\n' ;\n    }\n    return codeList ;\n  }\n\n} // end UnitTablesFactory\n\n\n// Create a singleton instance and (to preserve the existing API) an object that\n// provides that instance via getInstance().\nvar unitTablesInstance = new UnitTablesFactory();\nexport const UnitTables = {\n  getInstance: function() {\n    return unitTablesInstance;\n  }\n}\n"],"file":"unitTables.js"}