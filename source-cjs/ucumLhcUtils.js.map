{"version":3,"sources":["../source/ucumLhcUtils.js"],"names":["Ucum","require","UnitTables","UnitString","UcumLhcUtils","constructor","getInstance","unitsCount","ucumJsonDefs","loadJsonDefs","uStrParser_","useHTMLInMessages","use","undefined","useBraceMsgForEachString","validateUnitString","uStr","suggest","valConv","resp","getSpecifiedUnit","theUnit","retObj","csCode_","name_","guidance_","status","convertUnitTo","fromUnitCode","fromVal","toUnitCode","molecularWeight","returnObj","trim","push","_checkFromVal","fromUnit","parseResp","concat","toUnit","convertFrom","moleExp_","Error","isMoleMassCommensurable","convertMolToMass","convertMassToMol","err","message","needMoleWeightMsg_","convertToBaseUnits","inputUnitLookup","unit","msg","retMsg","length","isArbitrary_","unitToExp","dimVec","dim_","dimVec_","baseUnitString","dimVecIndexToBaseUnit","dimVecIndexToBaseUnit_","i","len","exp","retUnitLookup","retUnit","magnitude","e","toString","fromUnitIsSpecial","isSpecial_","responseObj","isNaN","intUtils_","isNumericString","checkSynonyms","theSyn","getSynonyms","uName","utab","getUnitByCode","parseString","console","log","unshift","origString","commensurablesList","fromName","commUnits","fromDim","getProperty","getUnitsByDimension"],"mappings":"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","sourcesContent":["/**\n * This class provides a single point of access to the LHC UCUM utilities\n *\n * @author Lee Mericle\n *\n */\nvar Ucum = require('./config.js').Ucum;\nimport {ucumJsonDefs} from './ucumJsonDefs.js';\nvar UnitTables = require('./unitTables.js').UnitTables;\nvar UnitString = require('./unitString.js').UnitString;\n\nimport * as intUtils_ from \"./ucumInternalUtils.js\";\n\n/**\n * UCUM external utilities class\n */\nexport class UcumLhcUtils {\n\n  /**\n   * Constructor.  This loads the json prefix and unit definitions if\n   * they haven't been loaded already and creates itself as a singleton object.\n   *\n   */\n  constructor() {\n\n      if (UnitTables.getInstance().unitsCount() === 0) {\n\n        // Load the prefix and unit objects\n        ucumJsonDefs.loadJsonDefs();\n      }\n\n      // Get the UnitString parser that will be used with this instance\n      // of the LHC Utilities\n      this.uStrParser_ = UnitString.getInstance();\n\n  } // end constructor\n\n\n  /**\n   * This method calls the useHTMLInMessages method on the UnitString\n   * object.  It should be called by web applications that use\n   * these utilities.\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useHTMLInMessages(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useHTMLInMessages(use);\n  }\n\n\n  /**\n   * This method calls the useBraceMsgForEachString method on the UnitString\n   * object.  It should be called by web applications where unit\n   * strings are validated individually (as opposed to validating a whole\n   * file of unit strings).\n   *\n   * @param use flag indicating whether or not to use the braces message;\n   *  defaults to true\n   */\n  useBraceMsgForEachString(use) {\n    if (use === undefined)\n      use = true ;\n    this.uStrParser_.useBraceMsgForEachString(use);\n  }\n\n\n  /**\n   * This method validates a unit string.  It first checks to see if the\n   * string passed in is a unit code that is found in the unit codes table.\n   * If it is not found it parses the string to see if it resolves to a\n   * valid unit string.\n   *\n   * If a valid unit cannot be found, the string is tested for some common\n   * errors, such as missing brackets or a missing multiplication operator.\n   * If found, the error is reported in the messages array that is returned.\n   *\n   * If a valid unit cannot be found and an error cannot be discerned, this\n   * may return, if requested, a list of suggested units in the messages\n   * array that is returned.  Suggestions are based on matching the expression\n   * with unit names and synonyms.\n   *\n   * @param uStr the string to be validated\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param valConv a string indicating if this validation request was initiated\n   *  by a validation task ('validate') or a conversion task ('convert'),\n   *  used only for the demo code, and the default is 'Validator' if the\n   *  parameter is not specified;\n   * @returns an object with five properties:\n   *  'status' will be 'valid' (the uStr is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *  'ucumCode' the valid ucum code, which may differ from what was passed\n   *    in (e.g., if 'Gauss' is passed in, this will contain 'G') OR null if\n   *    the string was flagged as invalid or an error occurred;\n   *  'msg' is an array of one or more messages, if the string is invalid or\n   *        an error occurred, indicating the problem, or an explanation of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated;\n   *  'unit' which is null if no unit is found, or a hash for a unit found:\n   *    'code' is the unit's ucum code (G in the above example;\n   *    'name' is the unit's name (Gauss in the above example); and\n   *    'guidance' is the unit's guidance/description data; and\n   *  'suggestions' if suggestions were requested and found, this is an array\n   *     of one or more hash objects.  Each hash contains three elements:\n   *     'msg' which is a message indicating what part of the uStr input\n   *        parameter the suggestions are for;\n   *     'invalidUnit' which is the unit expression the suggestions are\n   *        for; and\n   *     'units' which is an array of data for each suggested unit found.\n   *        Each array will contain the unit code, the unit name and the\n   *        unit guidance (if any).\n   *     If no suggestions were requested and found, this property is not\n   *     returned.\n   */\n  validateUnitString(uStr, suggest, valConv) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (valConv === undefined)\n      valConv = 'validate' ;\n\n    let resp = this.getSpecifiedUnit(uStr, valConv, suggest);\n    let theUnit = resp['unit'];\n    let retObj = !theUnit ? {'ucumCode': null} :\n      {'ucumCode': resp['origString'],\n       'unit': {'code': theUnit.csCode_,\n                'name': theUnit.name_,\n                'guidance': theUnit.guidance_ }};\n    retObj.status = resp.status;\n    if (resp['suggestions']) {\n      retObj['suggestions'] = resp['suggestions'];\n    }\n    retObj['msg'] = resp['retMsg'];\n    return retObj;\n\n  } // end validateUnitString\n\n\n  /**\n   * This method converts one unit to another\n   *\n   * @param fromUnitCode the unit code/expression/string of the unit to be converted\n   * @param fromVal the number of \"from\" units to be converted to \"to\" units\n   * @param toUnitCode the unit code/expression/string of the unit that the from\n   *  field is to be converted to\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @param molecularWeight the molecular weight of the substance in question\n   *  when a conversion is being requested from mass to moles and vice versa.\n   *  This is required when one of the units represents a value in moles.  It is\n   *  ignored if neither unit includes a measurement in moles.\n   * @returns a hash with six elements:\n   *  'status' that will be: 'succeeded' if the conversion was successfully\n   *     calculated; 'failed' if the conversion could not be made, e.g., if\n   *     the units are not commensurable; or 'error' if an error occurred;\n   *  'toVal' the numeric value indicating the conversion amount, or null\n   *     if the conversion failed (e.g., if the units are not commensurable);\n   *  'msg' is an array message, if the string is invalid or an error occurred,\n   *        indicating the problem, or an explanation of a substitution such as\n   *        the substitution of 'G' for 'Gauss', or an empty array if no\n   *        messages were generated;\n   *  'suggestions' if suggestions were requested and found, this is a hash\n   *     that contains at most two elements:\n   *     'from' which, if the fromUnitCode input parameter or one or more of\n   *       its components could not be found, is an array one or more hash\n   *       objects.  Each hash contains three elements:\n   *         'msg' which is a message indicating what unit expression the\n   *            suggestions are for;\n   *         'invalidUnit' which is the unit expression the suggestions\n   *            are for; and\n   *         'units' which is an array of data for each suggested unit found.\n   *            Each array will contain the unit code, the unit name and the\n   *            unit guidance (if any).\n   *       If no suggestions were found for the fromUnitCode this element\n   *       will not be included.\n   *     'to' which, if the \"to\" unit expression or one or more of its\n   *       components could not be found, is an array one or more hash objects.  Each hash\n   *       contains three elements:\n   *         'msg' which is a message indicating what toUnitCode input\n   *            parameter the suggestions are for;\n   *         'invalidUnit' which is the unit expression the suggestions\n   *            are for; and\n   *         'units' which is an array of data for each suggested unit found.\n   *            Each array will contain the unit code, the unit name and the\n   *            unit guidance (if any).\n   *       If no suggestions were found for the toUnitCode this element\n   *       will not be included.\n   *    No 'suggestions' element will be included in the returned hash\n   *    object if none were found, whether or not they were requested.\n   *  'fromUnit' the unit object for the fromUnitCode passed in; returned\n   *     in case it's needed for additional data from the object; and\n   *  'toUnit' the unit object for the toUnitCode passed in; returned\n   *     in case it's needed for additional data from the object.\n   */\n  convertUnitTo(fromUnitCode, fromVal, toUnitCode, suggest, molecularWeight) {\n    if (suggest === undefined)\n      suggest = false ;\n\n    if (molecularWeight === undefined)\n      molecularWeight = null ;\n\n    let returnObj = {'status' : 'failed',\n                     'toVal' : null,\n                     'msg' : []} ;\n\n    if (fromUnitCode) {\n      fromUnitCode = fromUnitCode.trim();\n    }\n    if (!fromUnitCode || fromUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"from\" unit expression specified.');\n    }\n    this._checkFromVal(fromVal, returnObj);\n    if (toUnitCode) {\n      toUnitCode = toUnitCode.trim();\n    }\n    if (!toUnitCode || toUnitCode == '') {\n      returnObj['status'] = 'error';\n      returnObj['msg'].push('No \"to\" unit expression specified.');\n    }\n    if (returnObj['status'] !== 'error') {\n      try {\n        let fromUnit = null;\n\n        let parseResp = this.getSpecifiedUnit(fromUnitCode, 'convert', suggest);\n        fromUnit = parseResp['unit'];\n        if (parseResp['retMsg'])\n          returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n        if (parseResp['suggestions']) {\n          returnObj['suggestions'] = {};\n          returnObj['suggestions']['from'] = parseResp['suggestions'];\n        }\n        if (!fromUnit) {\n          returnObj['msg'].push(`Unable to find a unit for ${fromUnitCode}, ` +\n            `so no conversion could be performed.`);\n        }\n\n        let toUnit = null;\n        parseResp = this.getSpecifiedUnit(toUnitCode, 'convert', suggest);\n        toUnit = parseResp['unit'];\n        if (parseResp['retMsg'])\n          returnObj['msg'] = returnObj['msg'].concat(parseResp['retMsg']);\n        if (parseResp['suggestions']) {\n          if (!returnObj['suggestions'])\n            returnObj['suggestions'] = {} ;\n          returnObj['suggestions']['to'] = parseResp['suggestions'];\n        }\n        if (!toUnit) {\n          returnObj['msg'].push(`Unable to find a unit for ${toUnitCode}, ` +\n                                `so no conversion could be performed.`);\n        }\n\n        if (fromUnit && toUnit) {\n          try {\n            // if no molecular weight was specified perform a normal conversion\n            if (!molecularWeight) {\n              returnObj['toVal'] = toUnit.convertFrom(fromVal, fromUnit);\n            }\n            else {\n              if (fromUnit.moleExp_ !== 0 && toUnit.moleExp_ !== 0) {\n                throw(new Error('A molecular weight was specified ' +\n                  'but a mass <-> mole conversion cannot be executed for two ' +\n                  'mole-based units.  No conversion was attempted.'));\n              }\n              if (fromUnit.moleExp_ === 0 && toUnit.moleExp_ === 0) {\n                throw(new Error('A molecular weight was specified ' +\n                  'but a mass <-> mole conversion cannot be executed when ' +\n                  'neither unit is mole-based.  No conversion was attempted.'));\n              }\n              if (!fromUnit.isMoleMassCommensurable(toUnit)) {\n                throw(new Error(`Sorry.  ${fromUnitCode} cannot be ` +\n                  `converted to ${toUnitCode}.`));\n              }\n\n              // if the \"from\" unit is a mole-based unit, assume a mole to mass\n              // request\n              if (fromUnit.moleExp_ !== 0) {\n                returnObj['toVal'] =\n                  fromUnit.convertMolToMass(fromVal, toUnit, molecularWeight);\n              }\n              // else the \"to\" unit must be the mole-based unit, so assume a\n              // mass to mole request\n              else {\n                returnObj['toVal'] =\n                  fromUnit.convertMassToMol(fromVal, toUnit, molecularWeight);\n              }\n            } // end if a molecular weight was specified\n\n            // if an error hasn't been thrown - either from convertFrom or here,\n            // set the return object to show success\n            returnObj['status'] = 'succeeded';\n            returnObj['fromUnit'] = fromUnit;\n            returnObj['toUnit'] = toUnit;\n          }\n          catch (err) {\n            returnObj['status'] = 'failed';\n            returnObj['msg'].push(err.message);\n          }\n\n\n        }  // end if we have the from and to units\n      }\n      catch (err) {\n        if (err.message == Ucum.needMoleWeightMsg_)\n          returnObj['status'] = 'failed';\n        else\n          returnObj['status'] = 'error';\n        returnObj['msg'].push(err.message);\n      }\n    }\n\n    return returnObj ;\n\n  } // end convertUnitTo\n\n\n  /**\n   *  Converts the given unit string into its base units, their exponents, and\n   *  a magnitude, and returns that data.\n   * @param fromUnit the unit string to be converted to base units information\n   * @param fromVal the number of \"from\" units to be converted\n   * @returns an object with the properties:\n   *  'status' indicates whether the result succeeded.  The value will be one of:\n   *    'succeeded':  the conversion was successfully calculated (which can be\n   *      true even if it was already in base units);\n   *    'invalid':  fromUnit is not a valid UCUM code;\n   *    'failed':  the conversion could not be made (e.g., if it is an \"arbitrary\" unit);\n   *    'error':  if an error occurred (an input or programming error)\n   *  'msg': an array of messages (possibly empty) if the string is invalid or\n   *        an error occurred, indicating the problem, or a suggestion of a\n   *        substitution such as the substitution of 'G' for 'Gauss', or\n   *        an empty array if no messages were generated.  There can also be a\n   *        message that is just informational or warning.\n   *  'magnitude': the new value when fromVal units of fromUnits is expressed in the base units.\n   *  'fromUnitIsSpecial': whether the input unit fromUnit is a \"special unit\"\n   *         as defined in UCUM.  This means there is some function applied to convert\n   *         between fromUnit and the base units, so the returned magnitude is likely not\n   *         useful as a scale factor for other conversions (i.e., it only has validity\n   *         and usefulness for the input values that produced it).\n   *  'unitToExp': a map of base units in fromUnit to their exponent\n   */\n  convertToBaseUnits(fromUnit, fromVal) {\n    let retObj = {};\n    this._checkFromVal(fromVal, retObj);\n    if (!retObj.status) { // could be set to 'error' by _checkFromVal\n      let inputUnitLookup = this.getSpecifiedUnit(fromUnit, 'validate');\n      retObj = {status: inputUnitLookup.status == 'valid' ? 'succeeded' : inputUnitLookup.status};\n      let unit = inputUnitLookup.unit;\n      retObj.msg = inputUnitLookup.retMsg || [];\n      if (!unit) {\n        if (inputUnitLookup.retMsg?.length == 0)\n          retObj.msg.push('Could not find unit information for '+fromUnit);\n      }\n      else if (unit.isArbitrary_) {\n        retObj.msg.push('Arbitrary units cannot be converted to base units or other units.');\n        retObj.status = 'failed';\n      }\n      else if (retObj.status == 'succeeded') {\n        let unitToExp = {};\n        let dimVec = unit.dim_?.dimVec_\n        let baseUnitString = '1';\n        if (dimVec) {\n          let dimVecIndexToBaseUnit = UnitTables.getInstance().dimVecIndexToBaseUnit_;\n          for (let i=0, len=dimVec.length; i<len; ++i) {\n            let exp = dimVec[i];\n            if (exp) {\n              unitToExp[dimVecIndexToBaseUnit[i]] = exp;\n              baseUnitString += '.' + dimVecIndexToBaseUnit[i] + exp;\n            }\n          }\n        }\n\n        // The unit might have a conversion function, which has to be applied; we\n        // cannot just assume unit_.magnitude_ is the magnitude in base units.\n        let retUnitLookup = this.getSpecifiedUnit(baseUnitString, 'validate');\n        // There should not be any error in retUnitLookup, unless there is a bug.\n        let retUnit = retUnitLookup.unit;\n        if (retUnitLookup.status !== 'valid') {\n          retObj.msg.push('Unable construct base unit string; tried '+baseUnitString);\n          retObj.status = 'error';\n        }\n        else {\n          try {\n            retObj.magnitude = retUnit.convertFrom(fromVal, unit);\n          }\n          catch (e) {\n            retObj.msg.push(e.toString());\n            retObj.status = 'error';\n          }\n          if (retObj.status == 'succeeded') {\n            retObj.unitToExp = unitToExp;\n            retObj.fromUnitIsSpecial = unit.isSpecial_;\n          }\n        }\n      }\n    }\n    return retObj;\n  }\n\n\n  /**\n   *  Checks the given value as to whether it is suitable as a \"from\" value in a\n   *  unit conversion.  If it is not, the responseObj will have its status set\n   *  to 'error' and a message added.\n   * @param fromVal The value to check\n   * @param responseObj the object that will be updated if the value is not\n   *  usable.\n   */\n  _checkFromVal(fromVal, responseObj) {\n    if (fromVal === null || isNaN(fromVal) || (typeof fromVal !== 'number' &&\n        !intUtils_.isNumericString(fromVal))) {\n      responseObj.status = 'error';\n      if (!responseObj.msg)\n        responseObj.msg = [];\n      responseObj.msg.push('No \"from\" value, or an invalid \"from\" value, ' +\n                         'was specified.');\n    }\n  }\n\n\n  /**\n   * This method accepts a term and looks for units that include it as\n   * a synonym - or that include the term in its name.\n   *\n   * @param theSyn the term to search for\n   * @returns a hash with up to three elements:\n   *  'status' contains the status of the request, which can be 'error',\n   *    'failed' or succeeded';\n   *  'msg' which contains a message for an error or if no units were found; and\n   *  'units' which is an array that contains one hash for each unit found:\n   *    'code' is the unit's csCode_\n   *    'name' is the unit's name_\n   *    'guidance' is the unit's guidance_\n   *\n   */\n  checkSynonyms(theSyn) {\n    let retObj = {} ;\n    if (theSyn === undefined || theSyn === null) {\n      retObj['status'] = 'error';\n      retObj['msg'] = 'No term specified for synonym search.'\n    }\n    else {\n      retObj = intUtils_.getSynonyms(theSyn);\n    } // end if a search synonym was supplied\n\n    return retObj ;\n\n  } // end checkSynonyms\n\n\n  /**\n   * This method parses a unit string to get (or try to get) the unit\n   * represented by the string.  It returns an error message if no string was specified\n   * or if any errors were encountered trying to get the unit.\n   *\n   * @param uName the expression/string representing the unit\n   * @param valConv indicates what type of request this is for - a request to\n   *  validate (pass in 'validate') or a request to convert (pass in 'convert')\n   * @param suggest a boolean to indicate whether or not suggestions are\n   *  requested for a string that cannot be resolved to a valid unit;\n   *  true indicates suggestions are wanted; false indicates they are not,\n   *  and is the default if the parameter is not specified;\n   * @returns a hash containing:\n   *   'status' will be 'valid' (uName is a valid UCUM code), 'invalid'\n   *     (the uStr is not a valid UCUM code, and substitutions or\n   *     suggestions may or may not be returned, depending on what was\n   *     requested and found); or 'error' (an input or programming error\n   *     occurred);\n   *   'unit' the unit object (or null if there were problems creating the\n   *     unit);\n   *   'origString' the possibly updated unit string passed in;\n   *   'retMsg' an array of user messages (informational, error or warning) if\n   *     any were generated (IF any were generated, otherwise will be an\n   *     empty array); and\n   *   'suggestions' is an array of 1 or more hash objects.  Each hash\n   *     contains three elements:\n   *       'msg' which is a message indicating what unit expression the\n   *          suggestions are for;\n   *       'invalidUnit' which is the unit expression the suggestions are\n   *          for; and\n   *       'units' which is an array of data for each suggested unit found.\n   *          Each array will contain the unit code, the unit name and the\n   *          unit guidance (if any).\n   *   The return hash will not contain a suggestions array if a valid unit\n   *   was found or if suggestions were not requested and found.\n   */\n  getSpecifiedUnit(uName, valConv, suggest) {\n\n    if (suggest === undefined)\n      suggest = false ;\n\n    let retObj = {};\n    retObj['retMsg'] = [];\n\n    if (!uName) {\n      retObj['retMsg'].push('No unit string specified.');\n    }\n    else {\n      let utab = UnitTables.getInstance();\n      uName = uName.trim();\n\n      // go ahead and just try using the name as the code.  This may or may not\n      // work, but if it does, it cuts out a lot of parsing.\n      let theUnit = utab.getUnitByCode(uName);\n\n      // If we found it, set the returned unit string to what was passed in;\n      // otherwise try parsing as a unit string\n      if (theUnit) {\n        retObj['unit'] = theUnit ;\n        retObj['origString'] = uName;\n      }\n      else {\n        try {\n          let resp = this.uStrParser_.parseString(uName, valConv, suggest);\n          retObj['unit'] = resp[0];\n          retObj['origString'] = resp[1];\n          if (resp[2])\n            retObj['retMsg'] = resp[2];\n          retObj['suggestions'] = resp[3];\n        }\n        catch (err) {\n          console.log(`Unit requested for unit string ${uName}.` +\n            'request unsuccessful; error thrown = ' + err.message);\n            retObj['retMsg'].unshift(`${uName} is not a valid unit.  ` +\n                                     `${err.message}`);\n        }\n      } // end if the unit was not found as a unit name\n    } // end if a unit expression was specified\n\n    // Set the status field\n    if (!retObj.unit) {\n      // No unit was found; check whether origString has a value\n      retObj.status = !retObj.origString ? 'error' : 'invalid';\n    }\n    else {\n      // Check whether substitutions were made to the unit string in order to\n      // find the unit\n      retObj.status = retObj.origString === uName ? 'valid': 'invalid';\n    }\n\n    return retObj;\n\n  } // end getSpecifiedUnit\n\n\n  /**\n   * This method retrieves a list of units commensurable, i.e., that can be\n   * converted from and to, a specified unit.  Returns an error if the \"from\"\n   * unit cannot be found.\n   *\n   * @param fromName the name/unit string of the \"from\" unit\n   * @returns an array containing two elements;\n   *   first element is the list of commensurable units if any were found\n   *   second element is an error message if the \"from\" unit is not found\n   */\n  commensurablesList(fromName) {\n\n    let retMsg = [];\n    let commUnits = null ;\n    let parseResp = this.getSpecifiedUnit(fromName, 'validate', false);\n    let fromUnit = parseResp['unit'];\n    if (parseResp['retMsg'].length > 0)\n      retMsg = parseResp['retMsg'] ;\n    if (!fromUnit) {\n      retMsg.push(`Could not find unit ${fromName}.`);\n    }\n    else {\n      let dimVec = null ;\n      let fromDim = fromUnit.getProperty('dim_');\n      if (!fromDim) {\n        retMsg.push('No commensurable units were found for ' + fromName) ;\n      }\n      else {\n        try {\n          dimVec = fromDim.getProperty('dimVec_');\n        }\n        catch (err) {\n          retMsg.push(err.message);\n          if (err.message ===\n            \"Dimension does not have requested property(dimVec_)\")\n            dimVec = null;\n        }\n        if (dimVec) {\n          let utab = UnitTables.getInstance();\n          commUnits = utab.getUnitsByDimension(dimVec);\n        }\n      } // end if the from unit has a dimension vector\n    } // end if we found a \"from\" unit\n    return [commUnits , retMsg];\n  } // end commensurablesList\n\n} // end UcumLhcUtils class\n\n\n/**\n *  This function exists ONLY until the original UcumLhcUtils constructor\n *  is called for the first time.  It's defined here in case getInstance\n *  is called before the constructor.   This calls the constructor.\n *\n *  The constructor redefines the getInstance function to return the\n *  singleton UcumLhcUtils object.  This is based on the UnitTables singleton\n *  implementation; see more detail in the UnitTables constructor description.\n *\n *  NO LONGER TRUE - not implemented as a singleton.  This method retained to\n *  avoid problems with calls to it that exist throughout the code.\n *\n *  @return the (formerly singleton) UcumLhcUtils object.\n */\nUcumLhcUtils.getInstance = function(){\n  return new UcumLhcUtils();\n} ;\n"],"file":"ucumLhcUtils.js"}